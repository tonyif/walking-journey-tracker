---
title: "Corp QA Enterprise Standards - C++"
description: "Enterprise-grade C++ development standards for scalable, production-ready systems"
tags:
  - cpp
  - c++
  - enterprise
  - qa
  - scalability
  - corp-qa
team: corp-qa
language: cpp
alwaysApply: true
---

# Corp QA Enterprise Standards - C++

## C++-Specific Enterprise Rules

- ALWAYS use modern C++ (C++17 or later)
- ALWAYS use CMake for build configuration (version 3.15+)
- ALWAYS enable all compiler warnings (-Wall -Wextra -Wpedantic)
- ALWAYS use smart pointers (avoid raw new/delete)
- ALWAYS follow RAII principles
- ALWAYS use const correctness
- ALWAYS implement move semantics for performance
- ALWAYS use Google Test or Catch2 for testing
- NEVER use `using namespace std` in headers
- NEVER ignore compiler warnings

## Project Structure

```
my-cpp-project/
‚îú‚îÄ‚îÄ CMakeLists.txt              # Root CMake configuration
‚îú‚îÄ‚îÄ README.md                   # Project documentation
‚îú‚îÄ‚îÄ CHANGELOG.md                # Version history
‚îú‚îÄ‚îÄ VERSION                     # Semantic version
‚îú‚îÄ‚îÄ CONTRIBUTING.md             # Contribution guidelines
‚îú‚îÄ‚îÄ SECURITY.md                 # Security policy
‚îú‚îÄ‚îÄ BUILD.md                    # Build instructions
‚îú‚îÄ‚îÄ TESTING.md                  # Testing guide
‚îú‚îÄ‚îÄ .clang-format              # Code formatting rules
‚îú‚îÄ‚îÄ .clang-tidy                # Static analysis config
‚îú‚îÄ‚îÄ conanfile.txt              # Conan dependencies (or vcpkg)
‚îú‚îÄ‚îÄ .gitlab-ci.yml             # CI/CD pipeline
‚îÇ
‚îú‚îÄ‚îÄ include/                   # Public headers
‚îÇ   ‚îî‚îÄ‚îÄ myproject/
‚îÇ       ‚îú‚îÄ‚îÄ myproject.hpp
‚îÇ       ‚îî‚îÄ‚îÄ utils.hpp
‚îÇ
‚îú‚îÄ‚îÄ src/                       # Implementation files
‚îÇ   ‚îú‚îÄ‚îÄ myproject.cpp
‚îÇ   ‚îî‚îÄ‚îÄ utils.cpp
‚îÇ
‚îú‚îÄ‚îÄ tests/                     # Test files
‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_utils.cpp
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_myproject.cpp
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_integration.cpp
‚îÇ   ‚îî‚îÄ‚îÄ e2e/
‚îÇ       ‚îî‚îÄ‚îÄ test_e2e.cpp
‚îÇ
‚îú‚îÄ‚îÄ examples/                  # Example usage
‚îÇ   ‚îî‚îÄ‚îÄ example_usage.cpp
‚îÇ
‚îú‚îÄ‚îÄ docs/                      # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ Doxyfile              # Doxygen configuration
‚îÇ   ‚îú‚îÄ‚îÄ ARCHITECTURE.md
‚îÇ   ‚îî‚îÄ‚îÄ API.md
‚îÇ
‚îú‚îÄ‚îÄ scripts/                   # Build/test scripts
‚îÇ   ‚îú‚îÄ‚îÄ build.sh
‚îÇ   ‚îú‚îÄ‚îÄ test.sh
‚îÇ   ‚îî‚îÄ‚îÄ coverage.sh
‚îÇ
‚îî‚îÄ‚îÄ extern/                    # External dependencies (if not using Conan)
```

## Version Management (C++)

### CMakeLists.txt Version Configuration

<example>
cmake_minimum_required(VERSION 3.15)

# Read version from VERSION file
file(READ "${CMAKE_CURRENT_SOURCE_DIR}/VERSION" VERSION_STRING)
string(STRIP "${VERSION_STRING}" VERSION_STRING)

# Parse semantic version
string(REGEX MATCH "([0-9]+)\\.([0-9]+)\\.([0-9]+)" _ ${VERSION_STRING})
set(VERSION_MAJOR ${CMAKE_MATCH_1})
set(VERSION_MINOR ${CMAKE_MATCH_2})
set(VERSION_PATCH ${CMAKE_MATCH_3})

project(MyProject 
    VERSION ${VERSION_STRING}
    LANGUAGES CXX
    DESCRIPTION "Enterprise-grade C++ project"
)

# Generate version header
configure_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/include/myproject/version.hpp.in"
    "${CMAKE_CURRENT_BINARY_DIR}/include/myproject/version.hpp"
)
</example>

### Version Header Template

<example>
// include/myproject/version.hpp.in
#pragma once

namespace myproject {

constexpr const char* VERSION = "@PROJECT_VERSION@";
constexpr int VERSION_MAJOR = @VERSION_MAJOR@;
constexpr int VERSION_MINOR = @VERSION_MINOR@;
constexpr int VERSION_PATCH = @VERSION_PATCH@;

} // namespace myproject
</example>

## Testing Standards (Google Test)

### CMakeLists.txt for Tests

<example>
# tests/CMakeLists.txt
enable_testing()

find_package(GTest REQUIRED)
include(GoogleTest)

# Unit tests
add_executable(unit_tests
    unit/test_utils.cpp
    unit/test_myproject.cpp
)

target_link_libraries(unit_tests
    PRIVATE
        myproject::myproject
        GTest::gtest_main
        GTest::gmock
)

target_compile_options(unit_tests
    PRIVATE
        -Wall -Wextra -Wpedantic -Werror
        --coverage  # Enable coverage
)

target_link_options(unit_tests
    PRIVATE
        --coverage
)

gtest_discover_tests(unit_tests)
</example>

### Test File Structure

<example>
// tests/unit/test_utils.cpp
#include <gtest/gtest.h>
#include <myproject/utils.hpp>

namespace myproject::test {

class UtilsTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Test setup
    }

    void TearDown() override {
        // Test cleanup
    }
};

TEST_F(UtilsTest, ValidInputReturnsExpectedValue) {
    // Arrange
    const int input = 42;
    const int expected = 84;
    
    // Act
    const int result = utils::double_value(input);
    
    // Assert
    EXPECT_EQ(result, expected);
}

TEST_F(UtilsTest, InvalidInputThrowsException) {
    EXPECT_THROW({
        utils::validate_input(-1);
    }, std::invalid_argument);
}

// Parameterized tests
class UtilsParameterizedTest : public ::testing::TestWithParam<std::pair<int, int>> {
};

TEST_P(UtilsParameterizedTest, DoubleValue) {
    auto [input, expected] = GetParam();
    EXPECT_EQ(utils::double_value(input), expected);
}

INSTANTIATE_TEST_SUITE_P(
    ValidInputs,
    UtilsParameterizedTest,
    ::testing::Values(
        std::make_pair(0, 0),
        std::make_pair(1, 2),
        std::make_pair(42, 84),
        std::make_pair(-10, -20)
    )
);

} // namespace myproject::test
</example>

## Code Quality Tools

### .clang-format Configuration

<example>
# .clang-format
BasedOnStyle: Google
Language: Cpp
Standard: c++17

IndentWidth: 4
TabWidth: 4
UseTab: Never

ColumnLimit: 100

AllowShortFunctionsOnASingleLine: Inline
AllowShortIfStatementsOnASingleLine: Never
AllowShortLoopsOnASingleLine: false

PointerAlignment: Left
DerivePointerAlignment: false

IncludeBlocks: Regroup
IncludeCategories:
  - Regex:           '^<.*\.h>'
    Priority:        1
  - Regex:           '^<.*'
    Priority:        2
  - Regex:           '.*'
    Priority:        3
</example>

### .clang-tidy Configuration

<example>
# .clang-tidy
Checks: >
  *,
  -fuchsia-*,
  -google-*,
  -llvm-*,
  -modernize-use-trailing-return-type,
  -readability-else-after-return,
  bugprone-*,
  cert-*,
  clang-analyzer-*,
  cppcoreguidelines-*,
  modernize-*,
  performance-*,
  readability-*

WarningsAsErrors: '*'

CheckOptions:
  - key: readability-identifier-naming.ClassCase
    value: CamelCase
  - key: readability-identifier-naming.FunctionCase
    value: lower_case
  - key: readability-identifier-naming.VariableCase
    value: lower_case
  - key: readability-identifier-naming.ConstantCase
    value: UPPER_CASE
  - key: readability-identifier-naming.NamespaceCase
    value: lower_case
</example>

## Modern C++ Best Practices

### Smart Pointers and RAII

<example>
#include <memory>
#include <string>
#include <vector>

namespace myproject {

// GOOD: Use smart pointers
class Resource {
public:
    static std::unique_ptr<Resource> create(const std::string& name) {
        return std::make_unique<Resource>(name);
    }
    
    Resource(const std::string& name) : name_(name) {
        // RAII: Acquire resource in constructor
        data_ = std::make_unique<int[]>(1024);
    }
    
    ~Resource() {
        // RAII: Release resource in destructor
        // Smart pointer automatically cleaned up
    }
    
    // Delete copy, enable move
    Resource(const Resource&) = delete;
    Resource& operator=(const Resource&) = delete;
    Resource(Resource&&) noexcept = default;
    Resource& operator=(Resource&&) noexcept = default;

private:
    std::string name_;
    std::unique_ptr<int[]> data_;
};

// BAD: Manual memory management
class BadResource {
public:
    BadResource() {
        data_ = new int[1024];  // ‚ùå Manual allocation
    }
    
    ~BadResource() {
        delete[] data_;  // ‚ùå Manual deallocation
    }

private:
    int* data_;
};

} // namespace myproject
</example>

### Const Correctness

<example>
namespace myproject {

class DataProcessor {
public:
    // Const member function (doesn't modify object)
    [[nodiscard]] int get_size() const noexcept {
        return data_.size();
    }
    
    // Const parameter (input parameter)
    void process(const std::vector<int>& input) {
        data_ = input;  // Copy is allowed
    }
    
    // Return const reference (prevent modification)
    [[nodiscard]] const std::vector<int>& get_data() const noexcept {
        return data_;
    }
    
    // Non-const overload for modification
    [[nodiscard]] std::vector<int>& get_data() noexcept {
        return data_;
    }

private:
    std::vector<int> data_;
};

} // namespace myproject
</example>

## CI/CD Pipeline (GitLab)

### .gitlab-ci.yml for C++

<example>
# .gitlab-ci.yml
stages:
  - build
  - test
  - analysis
  - deploy

variables:
  CMAKE_VERSION: "3.20"
  CXX_STANDARD: "17"

.build_template: &build_job
  stage: build
  before_script:
    - apt-get update && apt-get install -y cmake build-essential
  script:
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_BUILD_TYPE=Release ..
    - cmake --build . --parallel $(nproc)
  artifacts:
    paths:
      - build/
    expire_in: 1 hour

build:linux:gcc:
  <<: *build_job
  image: gcc:11
  script:
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_COMPILER=g++ ..
    - cmake --build . --parallel $(nproc)

build:linux:clang:
  <<: *build_job
  image: silkeh/clang:15
  script:
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_COMPILER=clang++ ..
    - cmake --build . --parallel $(nproc)

test:unit:
  stage: test
  image: gcc:11
  dependencies:
    - build:linux:gcc
  script:
    - cd build
    - ctest --output-on-failure --parallel $(nproc)
  coverage: '/lines: \d+\.\d+%/'

test:coverage:
  stage: test
  image: gcc:11
  dependencies:
    - build:linux:gcc
  before_script:
    - apt-get update && apt-get install -y lcov
  script:
    - cd build
    - cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON ..
    - cmake --build . --parallel $(nproc)
    - ctest --output-on-failure
    - lcov --capture --directory . --output-file coverage.info
    - lcov --remove coverage.info '/usr/*' '*/tests/*' --output-file coverage.info
    - lcov --list coverage.info
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: build/coverage.xml

analysis:clang-tidy:
  stage: analysis
  image: silkeh/clang:15
  script:
    - apt-get update && apt-get install -y cmake clang-tidy
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..
    - clang-tidy ../src/*.cpp -p . -- -std=c++17

analysis:cppcheck:
  stage: analysis
  image: gcc:11
  before_script:
    - apt-get update && apt-get install -y cppcheck
  script:
    - cppcheck --enable=all --error-exitcode=1 --suppress=missingIncludeSystem src/
  allow_failure: true

analysis:sanitizer:
  stage: analysis
  image: gcc:11
  script:
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_BUILD_TYPE=Debug 
            -DCMAKE_CXX_FLAGS="-fsanitize=address,undefined -fno-omit-frame-pointer" ..
    - cmake --build . --parallel $(nproc)
    - ctest --output-on-failure
</example>

## Security Standards (C++)

### Secure Coding Practices

<example>
#include <string>
#include <string_view>
#include <optional>
#include <filesystem>

namespace myproject::security {

// Buffer overflow protection
class SecureBuffer {
public:
    explicit SecureBuffer(size_t size) : data_(size), size_(size) {}
    
    // Bounds-checked write
    bool write(size_t offset, const std::string_view data) {
        if (offset + data.size() > size_) {
            return false;  // Prevent overflow
        }
        std::copy(data.begin(), data.end(), data_.begin() + offset);
        return true;
    }
    
    // Bounds-checked read
    std::optional<std::string_view> read(size_t offset, size_t length) const {
        if (offset + length > size_) {
            return std::nullopt;  // Prevent overflow
        }
        return std::string_view(data_.data() + offset, length);
    }

private:
    std::vector<char> data_;
    size_t size_;
};

// Path traversal prevention
class SecurePath {
public:
    static std::optional<std::filesystem::path> validate_path(
        const std::filesystem::path& base_dir,
        const std::filesystem::path& user_path
    ) {
        // Normalize paths
        auto base = std::filesystem::canonical(base_dir);
        auto full = std::filesystem::weakly_canonical(base / user_path);
        
        // Check if full path is within base directory
        auto [root, _] = std::mismatch(base.begin(), base.end(), full.begin());
        if (root != base.end()) {
            return std::nullopt;  // Path traversal detected
        }
        
        return full;
    }
};

// Input validation
class Validator {
public:
    // SQL injection prevention (for embedded SQL)
    static std::string sanitize_sql_string(const std::string& input) {
        std::string result;
        result.reserve(input.size() * 2);
        
        for (char c : input) {
            if (c == '\'') {
                result += "''";  // Escape single quotes
            } else {
                result += c;
            }
        }
        
        return result;
    }
    
    // Command injection prevention
    static bool is_safe_filename(const std::string& filename) {
        // Only allow alphanumeric, underscore, dash, dot
        return std::all_of(filename.begin(), filename.end(), [](char c) {
            return std::isalnum(c) || c == '_' || c == '-' || c == '.';
        });
    }
};

} // namespace myproject::security
</example>

## Dependency Management

### Conan (conanfile.txt)

<example>
# conanfile.txt
[requires]
gtest/1.14.0
fmt/10.1.1
spdlog/1.12.0
nlohmann_json/3.11.2

[generators]
CMakeDeps
CMakeToolchain

[options]
gtest:shared=False
</example>

### CMake Integration with Conan

<example>
# CMakeLists.txt
cmake_minimum_required(VERSION 3.15)
project(MyProject VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Conan setup
list(APPEND CMAKE_PREFIX_PATH ${CMAKE_BINARY_DIR})
find_package(GTest REQUIRED)
find_package(fmt REQUIRED)
find_package(spdlog REQUIRED)
find_package(nlohmann_json REQUIRED)

# Your library
add_library(myproject
    src/myproject.cpp
    src/utils.cpp
)

target_include_directories(myproject
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
)

target_link_libraries(myproject
    PUBLIC
        fmt::fmt
        spdlog::spdlog
        nlohmann_json::nlohmann_json
)

target_compile_options(myproject
    PRIVATE
        -Wall -Wextra -Wpedantic -Werror
)

# Enable testing
enable_testing()
add_subdirectory(tests)
</example>

## Performance Benchmarking

### Google Benchmark Integration

<example>
// benchmarks/benchmark_utils.cpp
#include <benchmark/benchmark.h>
#include <myproject/utils.hpp>

namespace myproject::benchmark {

static void BM_DoubleValue(::benchmark::State& state) {
    const int input = 42;
    
    for (auto _ : state) {
        ::benchmark::DoNotOptimize(utils::double_value(input));
    }
    
    state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_DoubleValue);

static void BM_VectorOperation(::benchmark::State& state) {
    const int size = state.range(0);
    std::vector<int> data(size);
    
    for (auto _ : state) {
        state.PauseTiming();
        std::iota(data.begin(), data.end(), 0);
        state.ResumeTiming();
        
        utils::process_vector(data);
    }
    
    state.SetComplexityN(size);
}
BENCHMARK(BM_VectorOperation)
    ->RangeMultiplier(2)
    ->Range(1<<10, 1<<18)
    ->Complexity();

} // namespace myproject::benchmark

BENCHMARK_MAIN();
</example>

## Documentation (Doxygen)

### Doxyfile Configuration

<example>
# docs/Doxyfile
PROJECT_NAME           = "MyProject"
PROJECT_NUMBER         = 1.0.0
PROJECT_BRIEF          = "Enterprise-grade C++ project"

INPUT                  = ../include ../src
RECURSIVE              = YES
EXCLUDE_PATTERNS       = */tests/* */extern/*

GENERATE_HTML          = YES
GENERATE_LATEX         = NO
GENERATE_XML           = YES

HTML_OUTPUT            = html
XML_OUTPUT             = xml

EXTRACT_ALL            = YES
EXTRACT_PRIVATE        = NO
EXTRACT_STATIC         = YES

SOURCE_BROWSER         = YES
INLINE_SOURCES         = NO

GENERATE_TREEVIEW      = YES
</example>

### Code Documentation

<example>
// include/myproject/utils.hpp
#pragma once

#include <string>
#include <vector>

namespace myproject::utils {

/**
 * @brief Doubles the input value.
 * 
 * This function takes an integer input and returns its double.
 * It is optimized for performance and is thread-safe.
 * 
 * @param value The input value to double
 * @return int The doubled value
 * 
 * @note This function is constexpr and can be evaluated at compile time.
 * @warning Overflow is not checked. Ensure input is within valid range.
 * 
 * @par Example:
 * @code
 * int result = double_value(42);  // result = 84
 * @endcode
 * 
 * @see halve_value()
 * @since 1.0.0
 */
[[nodiscard]] constexpr int double_value(int value) noexcept {
    return value * 2;
}

/**
 * @brief Processes a vector of integers.
 * 
 * @param data Input vector to process (modified in-place)
 * @throws std::invalid_argument if vector is empty
 * 
 * @par Complexity:
 * Time: O(n), Space: O(1)
 */
void process_vector(std::vector<int>& data);

} // namespace myproject::utils
</example>

## Build Scripts

### build.sh

<example language="bash">
#!/bin/bash
# scripts/build.sh

set -e

BUILD_TYPE=${1:-Release}
BUILD_DIR="build"

echo "üî® Building project in ${BUILD_TYPE} mode..."

# Create build directory
mkdir -p ${BUILD_DIR}
cd ${BUILD_DIR}

# Install Conan dependencies
conan install .. --build=missing

# Configure CMake
cmake .. \
    -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
    -DENABLE_TESTING=ON

# Build
cmake --build . --parallel $(nproc)

echo "‚úÖ Build complete!"
</example>

### test.sh

<example language="bash">
#!/bin/bash
# scripts/test.sh

set -e

cd build

echo "üß™ Running tests..."

# Run tests with output
ctest --output-on-failure --parallel $(nproc)

echo "‚úÖ All tests passed!"
</example>

### coverage.sh

<example language="bash">
#!/bin/bash
# scripts/coverage.sh

set -e

BUILD_DIR="build"

echo "üìä Generating coverage report..."

# Clean previous build
rm -rf ${BUILD_DIR}
mkdir -p ${BUILD_DIR}
cd ${BUILD_DIR}

# Build with coverage flags
cmake .. -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON
cmake --build . --parallel $(nproc)

# Run tests
ctest --output-on-failure

# Generate coverage report
lcov --capture --directory . --output-file coverage.info
lcov --remove coverage.info '/usr/*' '*/tests/*' '*/extern/*' --output-file coverage.info
lcov --list coverage.info

# Generate HTML report
genhtml coverage.info --output-directory coverage_html

echo "‚úÖ Coverage report generated in build/coverage_html/index.html"
</example>

## Release Checklist (C++)

- [ ] All tests pass (`ctest`)
- [ ] Coverage >80% (`lcov`)
- [ ] No compiler warnings (gcc -Wall -Wextra -Wpedantic)
- [ ] clang-tidy passes
- [ ] cppcheck passes
- [ ] Address sanitizer clean
- [ ] Memory leaks checked (valgrind)
- [ ] VERSION file updated
- [ ] CHANGELOG.md updated
- [ ] Doxygen documentation generated
- [ ] Git tagged (`git tag v1.0.0`)
- [ ] CI/CD pipeline green

## Summary: C++ vs Python Standards

| Aspect | Python | C++ |
|--------|--------|-----|
| **Build Tool** | pip/uv | CMake + Conan |
| **Testing** | pytest | Google Test |
| **Coverage** | pytest-cov | lcov |
| **Linting** | pylint | clang-tidy |
| **Formatting** | black | clang-format |
| **Documentation** | Sphinx | Doxygen |
| **Security** | Bandit | cppcheck + sanitizers |
| **Benchmarking** | Not standard | Google Benchmark |
| **Package Manager** | PyPI | Conan/vcpkg |
