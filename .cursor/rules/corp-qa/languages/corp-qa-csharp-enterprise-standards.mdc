---
title: "Corp QA Enterprise Standards - C#"
description: "Enterprise-grade C# (.NET) development standards for scalable, production-ready systems"
tags:
  - csharp
  - dotnet
  - enterprise
  - qa
  - scalability
  - corp-qa
team: corp-qa
language: csharp
alwaysApply: true
---

# Corp QA Enterprise Standards - C# (.NET)

## C#-Specific Enterprise Rules

- ALWAYS use .NET 6.0 or later (LTS versions preferred)
- ALWAYS follow .NET naming conventions (PascalCase for public members)
- ALWAYS use nullable reference types (enabled by default in .NET 6+)
- ALWAYS implement `IDisposable` for resources
- ALWAYS use async/await for I/O operations
- ALWAYS use xUnit or NUnit for testing
- ALWAYS run code analysis (Roslyn analyzers)
- NEVER ignore compiler warnings
- NEVER use `goto` statements
- ALWAYS use `using` statements for disposable resources

## Project Structure

```
MyProject/
├── MyProject.sln                  # Solution file
├── README.md                      # Project documentation
├── CHANGELOG.md                   # Version history
├── VERSION                        # Semantic version
├── CONTRIBUTING.md                # Contribution guidelines
├── SECURITY.md                    # Security policy
├── .editorconfig                  # Code style configuration
├── .gitlab-ci.yml                # CI/CD pipeline
├── Directory.Build.props          # Common MSBuild properties
├── Directory.Packages.props       # Central package management
│
├── src/
│   ├── MyProject/
│   │   ├── MyProject.csproj
│   │   ├── Program.cs
│   │   ├── Models/
│   │   │   └── User.cs
│   │   ├── Services/
│   │   │   └── UserService.cs
│   │   ├── Controllers/
│   │   │   └── UserController.cs
│   │   └── Utils/
│   │       └── ValidationHelper.cs
│   │
│   └── MyProject.Core/
│       ├── MyProject.Core.csproj
│       ├── Interfaces/
│       │   └── IUserService.cs
│       └── Models/
│           └── UserDto.cs
│
├── tests/
│   ├── MyProject.UnitTests/
│   │   ├── MyProject.UnitTests.csproj
│   │   ├── Services/
│   │   │   └── UserServiceTests.cs
│   │   └── Utils/
│   │       └── ValidationHelperTests.cs
│   │
│   ├── MyProject.IntegrationTests/
│   │   ├── MyProject.IntegrationTests.csproj
│   │   └── Api/
│   │       └── UserControllerIntegrationTests.cs
│   │
│   └── MyProject.E2ETests/
│       ├── MyProject.E2ETests.csproj
│       └── Scenarios/
│           └── UserWorkflowTests.cs
│
├── benchmarks/
│   └── MyProject.Benchmarks/
│       ├── MyProject.Benchmarks.csproj
│       └── UserServiceBenchmarks.cs
│
└── docs/
    ├── ARCHITECTURE.md
    └── API.md
```

## Project Configuration

### MyProject.csproj

<example>
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
    
    <!-- Version from VERSION file -->
    <Version>1.0.0</Version>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <FileVersion>1.0.0.0</FileVersion>
    
    <!-- Package metadata -->
    <Authors>Your Name</Authors>
    <Company>NVIDIA</Company>
    <Product>MyProject</Product>
    <Description>Enterprise-grade .NET project</Description>
    <Copyright>Copyright © NVIDIA 2025</Copyright>
  </PropertyGroup>

  <!-- Enable code analysis -->
  <PropertyGroup>
    <EnableNETAnalyzers>true</EnableNETAnalyzers>
    <AnalysisLevel>latest</AnalysisLevel>
    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  </ItemGroup>

  <!-- Code analyzers -->
  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.2.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
    </PackageReference>
    <PackageReference Include="SonarAnalyzer.CSharp" Version="9.16.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
    </PackageReference>
  </ItemGroup>

</Project>
</example>

### Directory.Build.props (Common Properties)

<example>
<Project>
  <PropertyGroup>
    <!-- Common settings for all projects -->
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    
    <!-- Read version from VERSION file -->
    <Version>$([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)VERSION').Trim())</Version>
    
    <!-- Output paths -->
    <BaseOutputPath>$(MSBuildThisFileDirectory)bin\$(Configuration)\</BaseOutputPath>
    <BaseIntermediateOutputPath>$(MSBuildThisFileDirectory)obj\$(Configuration)\</BaseIntermediateOutputPath>
  </PropertyGroup>
</Project>
</example>

### Directory.Packages.props (Central Package Management)

<example>
<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  
  <ItemGroup>
    <!-- Core dependencies -->
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="8.0.0" />
    <PackageVersion Include="Serilog.AspNetCore" Version="8.0.0" />
    
    <!-- Testing -->
    <PackageVersion Include="xunit" Version="2.6.3" />
    <PackageVersion Include="xunit.runner.visualstudio" Version="2.5.5" />
    <PackageVersion Include="coverlet.collector" Version="6.0.0" />
    <PackageVersion Include="FluentAssertions" Version="6.12.0" />
    <PackageVersion Include="Moq" Version="4.20.70" />
    
    <!-- Code analysis -->
    <PackageVersion Include="StyleCop.Analyzers" Version="1.2.0" />
    <PackageVersion Include="SonarAnalyzer.CSharp" Version="9.16.0" />
  </ItemGroup>
</Project>
</example>

## Version Management (C#/.NET)

### PowerShell Version Update Script

<example language="powershell">
# scripts/Update-Version.ps1
param(
    [Parameter(Mandatory=$true)]
    [string]$NewVersion
)

# Validate semantic version
if ($NewVersion -notmatch '^\d+\.\d+\.\d+$') {
    Write-Error "Version must be in format X.Y.Z"
    exit 1
}

# Update VERSION file
Set-Content -Path "VERSION" -Value $NewVersion

# Update all .csproj files
Get-ChildItem -Path "src" -Filter "*.csproj" -Recurse | ForEach-Object {
    $content = Get-Content $_.FullName -Raw
    $content = $content -replace '<Version>.*</Version>', "<Version>$NewVersion</Version>"
    $content = $content -replace '<AssemblyVersion>.*</AssemblyVersion>', "<AssemblyVersion>$NewVersion.0</AssemblyVersion>"
    $content = $content -replace '<FileVersion>.*</FileVersion>', "<FileVersion>$NewVersion.0</FileVersion>"
    Set-Content -Path $_.FullName -Value $content
}

Write-Host "✅ Version updated to $NewVersion" -ForegroundColor Green
Write-Host ""
Write-Host "Next steps:" -ForegroundColor Yellow
Write-Host "  1. Update CHANGELOG.md"
Write-Host "  2. Git commit: git commit -am 'Release v$NewVersion'"
Write-Host "  3. Git tag: git tag v$NewVersion"
Write-Host "  4. Git push: git push --tags"
</example>

## Testing Standards (xUnit)

### Unit Tests

<example>
// tests/MyProject.UnitTests/Services/UserServiceTests.cs
using FluentAssertions;
using Moq;
using MyProject.Core.Interfaces;
using MyProject.Core.Models;
using MyProject.Services;
using Xunit;

namespace MyProject.UnitTests.Services;

public class UserServiceTests
{
    private readonly Mock<IUserRepository> _repositoryMock;
    private readonly Mock<ILogger<UserService>> _loggerMock;
    private readonly UserService _sut;

    public UserServiceTests()
    {
        _repositoryMock = new Mock<IUserRepository>();
        _loggerMock = new Mock<ILogger<UserService>>();
        _sut = new UserService(_repositoryMock.Object, _loggerMock.Object);
    }

    [Fact]
    public async Task GetUserAsync_ValidId_ReturnsUser()
    {
        // Arrange
        const int userId = 42;
        var expectedUser = new User { Id = userId, Name = "Test User" };
        _repositoryMock
            .Setup(x => x.GetByIdAsync(userId))
            .ReturnsAsync(expectedUser);

        // Act
        var result = await _sut.GetUserAsync(userId);

        // Assert
        result.Should().NotBeNull();
        result.Id.Should().Be(userId);
        result.Name.Should().Be("Test User");
        _repositoryMock.Verify(x => x.GetByIdAsync(userId), Times.Once);
    }

    [Fact]
    public async Task GetUserAsync_InvalidId_ThrowsArgumentException()
    {
        // Arrange
        const int invalidId = -1;

        // Act
        Func<Task> act = async () => await _sut.GetUserAsync(invalidId);

        // Assert
        await act.Should().ThrowAsync<ArgumentException>()
            .WithMessage("*userId*")
            .WithMessage("*positive*");
    }

    [Theory]
    [InlineData(1, "Alice")]
    [InlineData(2, "Bob")]
    [InlineData(3, "Charlie")]
    public async Task GetUserAsync_MultipleValidIds_ReturnsCorrectUsers(int userId, string expectedName)
    {
        // Arrange
        _repositoryMock
            .Setup(x => x.GetByIdAsync(userId))
            .ReturnsAsync(new User { Id = userId, Name = expectedName });

        // Act
        var result = await _sut.GetUserAsync(userId);

        // Assert
        result.Name.Should().Be(expectedName);
    }
}
</example>

### Integration Tests

<example>
// tests/MyProject.IntegrationTests/Api/UserControllerIntegrationTests.cs
using System.Net;
using System.Net.Http.Json;
using FluentAssertions;
using Microsoft.AspNetCore.Mvc.Testing;
using MyProject.Core.Models;
using Xunit;

namespace MyProject.IntegrationTests.Api;

public class UserControllerIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;

    public UserControllerIntegrationTests(WebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task GetUser_ValidId_ReturnsOk()
    {
        // Arrange
        const int userId = 1;

        // Act
        var response = await _client.GetAsync($"/api/users/{userId}");
        var user = await response.Content.ReadFromJsonAsync<User>();

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.OK);
        user.Should().NotBeNull();
        user!.Id.Should().Be(userId);
    }

    [Fact]
    public async Task GetUser_InvalidId_ReturnsNotFound()
    {
        // Arrange
        const int invalidId = 9999;

        // Act
        var response = await _client.GetAsync($"/api/users/{invalidId}");

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.NotFound);
    }
}
</example>

### Test Configuration

<example>
<!-- tests/MyProject.UnitTests/MyProject.UnitTests.csproj -->
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <IsPackable>false</IsPackable>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="xunit" />
    <PackageReference Include="xunit.runner.visualstudio">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
    </PackageReference>
    <PackageReference Include="FluentAssertions" />
    <PackageReference Include="Moq" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\MyProject\MyProject.csproj" />
  </ItemGroup>

</Project>
</example>

## CI/CD Pipeline (GitLab)

### .gitlab-ci.yml for .NET

<example>
# .gitlab-ci.yml
stages:
  - build
  - test
  - analysis
  - package
  - deploy

variables:
  DOTNET_VERSION: "8.0"
  SOLUTION_FILE: "MyProject.sln"

.dotnet_job: &dotnet_template
  image: mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION}
  before_script:
    - dotnet --version

build:
  <<: *dotnet_template
  stage: build
  script:
    - dotnet restore ${SOLUTION_FILE}
    - dotnet build ${SOLUTION_FILE} --configuration Release --no-restore
  artifacts:
    paths:
      - bin/
      - obj/
    expire_in: 1 hour

test:unit:
  <<: *dotnet_template
  stage: test
  dependencies:
    - build
  script:
    - dotnet test ${SOLUTION_FILE} 
        --configuration Release 
        --no-build 
        --filter "FullyQualifiedName~UnitTests"
        --verbosity normal
        --collect:"XPlat Code Coverage"
        --results-directory ./TestResults
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: TestResults/*/coverage.cobertura.xml
  coverage: '/Total\s+\|\s+(\d+(?:\.\d+)?)/'

test:integration:
  <<: *dotnet_template
  stage: test
  dependencies:
    - build
  script:
    - dotnet test ${SOLUTION_FILE}
        --configuration Release
        --no-build
        --filter "FullyQualifiedName~IntegrationTests"
        --verbosity normal

analysis:security:
  <<: *dotnet_template
  stage: analysis
  script:
    - dotnet tool install --global security-scan
    - security-scan ${SOLUTION_FILE}
  allow_failure: true

analysis:format:
  <<: *dotnet_template
  stage: analysis
  script:
    - dotnet format ${SOLUTION_FILE} --verify-no-changes --verbosity diagnostic

package:nuget:
  <<: *dotnet_template
  stage: package
  script:
    - dotnet pack ${SOLUTION_FILE} 
        --configuration Release 
        --output ./packages
  artifacts:
    paths:
      - packages/*.nupkg
    expire_in: 7 days
  only:
    - main
    - tags

deploy:production:
  <<: *dotnet_template
  stage: deploy
  script:
    - dotnet publish src/MyProject/MyProject.csproj
        --configuration Release
        --output ./publish
    # Add deployment commands here
  artifacts:
    paths:
      - publish/
  only:
    - tags
  when: manual
</example>

## Code Quality (.editorconfig)

### .editorconfig for C#

<example>
# .editorconfig
root = true

[*]
charset = utf-8
end_of_line = crlf
trim_trailing_whitespace = true
insert_final_newline = true
indent_style = space
indent_size = 4

[*.{cs,vb}]
dotnet_sort_system_directives_first = true
dotnet_separate_import_directive_groups = false

# Naming conventions
dotnet_naming_rule.interfaces_should_be_prefixed_with_i.severity = warning
dotnet_naming_rule.interfaces_should_be_prefixed_with_i.symbols = interface
dotnet_naming_rule.interfaces_should_be_prefixed_with_i.style = begins_with_i

dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.capitalization = pascal_case

# Code style rules
csharp_prefer_braces = true:warning
csharp_prefer_simple_using_statement = true:suggestion
csharp_style_namespace_declarations = file_scoped:warning

# Null-checking preferences
csharp_style_conditional_delegate_call = true:suggestion
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:warning

# Modern C# features
csharp_prefer_simple_default_expression = true:suggestion
csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion
csharp_style_pattern_matching_over_as_with_null_check = true:suggestion
csharp_style_inlined_variable_declaration = true:suggestion
csharp_prefer_static_local_function = true:suggestion

[*.{yml,yaml}]
indent_size = 2

[*.{json}]
indent_size = 2
</example>

## Security Standards (.NET)

### Secure Coding Practices

<example>
using System.Security.Cryptography;
using System.Text;
using Microsoft.Data.SqlClient;

namespace MyProject.Security;

public class SecureOperations
{
    // Password hashing (use BCrypt or Argon2 in production)
    public static string HashPassword(string password)
    {
        using var sha256 = SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(password);
        var hash = sha256.ComputeHash(bytes);
        return Convert.ToBase64String(hash);
    }

    // Parameterized SQL queries
    public async Task<User?> GetUserAsync(int userId)
    {
        const string query = "SELECT Id, Name, Email FROM Users WHERE Id = @UserId";
        
        await using var connection = new SqlConnection(_connectionString);
        await using var command = new SqlCommand(query, connection);
        command.Parameters.AddWithValue("@UserId", userId);
        
        await connection.OpenAsync();
        await using var reader = await command.ExecuteReaderAsync();
        
        if (await reader.ReadAsync())
        {
            return new User
            {
                Id = reader.GetInt32(0),
                Name = reader.GetString(1),
                Email = reader.GetString(2)
            };
        }
        
        return null;
    }

    // Input validation
    public static bool IsValidEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return false;

        try
        {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        }
        catch
        {
            return false;
        }
    }

    // Path traversal prevention
    public static string ValidatePath(string basePath, string userPath)
    {
        var fullPath = Path.GetFullPath(Path.Combine(basePath, userPath));
        
        if (!fullPath.StartsWith(basePath, StringComparison.OrdinalIgnoreCase))
        {
            throw new ArgumentException("Path traversal detected", nameof(userPath));
        }
        
        return fullPath;
    }
}
</example>

## Structured Logging (Serilog)

### Logging Configuration

<example>
// Program.cs
using Serilog;
using Serilog.Events;

var builder = WebApplication.CreateBuilder(args);

// Configure Serilog
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .MinimumLevel.Override("Microsoft", LogEventLevel.Warning)
    .MinimumLevel.Override("System", LogEventLevel.Warning)
    .Enrich.FromLogContext()
    .Enrich.WithMachineName()
    .Enrich.WithEnvironmentName()
    .WriteTo.Console(
        outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}")
    .WriteTo.File(
        path: "logs/app-.log",
        rollingInterval: RollingInterval.Day,
        outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}",
        retainedFileCountLimit: 30)
    .WriteTo.File(
        new Serilog.Formatting.Json.JsonFormatter(),
        path: "logs/app-.json",
        rollingInterval: RollingInterval.Day,
        retainedFileCountLimit: 30)
    .CreateLogger();

builder.Host.UseSerilog();

var app = builder.Build();

app.UseSerilogRequestLogging();

app.Run();
</example>

### Logging Usage

<example>
using Serilog;

namespace MyProject.Services;

public class UserService
{
    private readonly ILogger<UserService> _logger;

    public UserService(ILogger<UserService> logger)
    {
        _logger = logger;
    }

    public async Task<User> GetUserAsync(int userId)
    {
        using (_logger.BeginScope(new Dictionary<string, object>
        {
            ["UserId"] = userId,
            ["Operation"] = "GetUser"
        }))
        {
            _logger.LogInformation("Fetching user {UserId}", userId);

            try
            {
                var user = await _repository.GetByIdAsync(userId);
                
                if (user == null)
                {
                    _logger.LogWarning("User {UserId} not found", userId);
                    throw new NotFoundException($"User {userId} not found");
                }

                _logger.LogInformation("Successfully retrieved user {UserId}", userId);
                return user;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error fetching user {UserId}", userId);
                throw;
            }
        }
    }
}
</example>

## Performance Benchmarking (BenchmarkDotNet)

### Benchmark Setup

<example>
// benchmarks/MyProject.Benchmarks/UserServiceBenchmarks.cs
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

namespace MyProject.Benchmarks;

[MemoryDiagnoser]
[SimpleJob(warmupCount: 3, iterationCount: 5)]
public class UserServiceBenchmarks
{
    private UserService _service = null!;
    private List<int> _userIds = null!;

    [GlobalSetup]
    public void Setup()
    {
        _service = new UserService(/* dependencies */);
        _userIds = Enumerable.Range(1, 1000).ToList();
    }

    [Benchmark(Baseline = true)]
    public async Task GetUser_Single()
    {
        await _service.GetUserAsync(42);
    }

    [Benchmark]
    [Arguments(100)]
    [Arguments(1000)]
    public async Task GetUsers_Batch(int count)
    {
        await Task.WhenAll(_userIds.Take(count).Select(_service.GetUserAsync));
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        BenchmarkRunner.Run<UserServiceBenchmarks>();
    }
}
</example>

## Release Checklist (C#/.NET)

- [ ] All tests pass (`dotnet test`)
- [ ] Code coverage >80%
- [ ] No build warnings (`dotnet build`)
- [ ] Code formatted (`dotnet format --verify-no-changes`)
- [ ] Security analysis passed
- [ ] NuGet packages up-to-date
- [ ] XML documentation complete
- [ ] VERSION file updated
- [ ] CHANGELOG.md updated
- [ ] Git tagged (`git tag v1.0.0`)
- [ ] CI/CD pipeline green

## Summary: .NET Enterprise Tools

| Feature | Tool |
|---------|------|
| **Build System** | MSBuild/dotnet CLI |
| **Testing** | xUnit/NUnit |
| **Mocking** | Moq |
| **Coverage** | coverlet |
| **Code Analysis** | Roslyn Analyzers |
| **Formatting** | dotnet format |
| **Documentation** | XML Documentation |
| **Logging** | Serilog/NLog |
| **Benchmarking** | BenchmarkDotNet |
| **Package Manager** | NuGet |
