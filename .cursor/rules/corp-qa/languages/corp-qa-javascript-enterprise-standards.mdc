---
title: "Corp QA Enterprise Standards - JavaScript"
description: "Enterprise-grade JavaScript (Node.js) development standards for scalable, production-ready systems"
tags:
  - javascript
  - nodejs
  - enterprise
  - qa
  - scalability
  - corp-qa
team: corp-qa
language: javascript
alwaysApply: true
---

# Corp QA Enterprise Standards - JavaScript

## JavaScript-Specific Enterprise Rules

- ALWAYS use Node.js 18 LTS or later
- ALWAYS use ES6+ features (const/let, arrow functions, async/await)
- ALWAYS use ESLint with recommended rules
- ALWAYS use Prettier for code formatting
- ALWAYS use JSDoc for documentation
- ALWAYS handle Promise rejections
- NEVER use `var` (use `const` or `let`)
- NEVER ignore ESLint warnings
- ALWAYS use strict mode (`'use strict'`)
- ALWAYS validate inputs

## Project Structure

```
my-js-project/
├── package.json               # Project manifest
├── package-lock.json          # Dependency lock
├── .eslintrc.js              # ESLint configuration
├── .prettierrc               # Prettier configuration
├── jest.config.js            # Jest configuration
├── .gitlab-ci.yml            # CI/CD pipeline
├── README.md                  # Project documentation
├── CHANGELOG.md               # Version history
├── VERSION                    # Semantic version
├── CONTRIBUTING.md            # Contribution guidelines
├── SECURITY.md                # Security policy
│
├── src/
│   ├── index.js              # Main entry point
│   ├── app.js                # Application setup
│   ├── routes/               # API routes
│   │   └── userRoutes.js
│   ├── controllers/          # Request handlers
│   │   └── userController.js
│   ├── services/             # Business logic
│   │   └── userService.js
│   ├── models/               # Data models
│   │   └── user.js
│   ├── middleware/           # Express middleware
│   │   └── auth.js
│   ├── utils/                # Utility functions
│   │   └── validator.js
│   └── config/               # Configuration
│       └── database.js
│
├── tests/                     # Test files
│   ├── unit/
│   │   └── userService.test.js
│   ├── integration/
│   │   └── api.test.js
│   └── e2e/
│       └── workflow.test.js
│
├── coverage/                  # Coverage reports (gitignored)
└── docs/                      # Documentation
    └── ARCHITECTURE.md
```

## package.json Configuration

### Enterprise package.json

<example>
{
  "name": "myproject",
  "version": "1.0.0",
  "description": "Enterprise-grade Node.js project",
  "main": "src/index.js",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  },
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix",
    "format": "prettier --write \"src/**/*.js\"",
    "format:check": "prettier --check \"src/**/*.js\"",
    "security:audit": "npm audit",
    "clean": "rm -rf coverage",
    "prepublishOnly": "npm run lint && npm test"
  },
  "keywords": ["enterprise", "nodejs", "production"],
  "author": "Your Name <your.email@nvidia.com>",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "joi": "^17.11.0",
    "winston": "^3.11.0",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "eslint": "^8.56.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-import": "^2.29.1",
    "eslint-plugin-jest": "^27.6.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.2",
    "prettier": "^3.1.1",
    "supertest": "^6.3.3"
  }
}
</example>

## ESLint Configuration

### .eslintrc.js for JavaScript

<example>
module.exports = {
  env: {
    node: true,
    es2022: true,
    jest: true,
  },
  extends: [
    'airbnb-base',
    'plugin:jest/recommended',
    'prettier',
  ],
  plugins: ['jest'],
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
  },
  rules: {
    // Enforce const for variables that are never reassigned
    'prefer-const': 'error',
    
    // Disallow var
    'no-var': 'error',
    
    // Require JSDoc comments
    'require-jsdoc': [
      'warn',
      {
        require: {
          FunctionDeclaration: true,
          MethodDefinition: true,
          ClassDeclaration: true,
        },
      },
    ],
    
    // Async/await
    'require-await': 'error',
    'no-return-await': 'error',
    
    // Error handling
    'no-throw-literal': 'error',
    'prefer-promise-reject-errors': 'error',
    
    // Console
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    
    // Complexity
    'complexity': ['warn', 15],
    'max-depth': ['warn', 4],
    'max-lines-per-function': ['warn', { max: 50, skipBlankLines: true, skipComments: true }],
    
    // Import order
    'import/order': [
      'error',
      {
        groups: ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'],
        'newlines-between': 'always',
        alphabetize: { order: 'asc', caseInsensitive: true },
      },
    ],
  },
};
</example>

## Code Quality Patterns

### JSDoc Documentation

<example>
/**
 * User service for managing user operations
 * @class
 */
class UserService {
  /**
   * Creates an instance of UserService
   * @param {Object} repository - The user repository
   */
  constructor(repository) {
    this.repository = repository;
  }

  /**
   * Retrieves a user by ID
   * @async
   * @param {number} userId - The user ID
   * @returns {Promise<Object>} The user object
   * @throws {NotFoundError} When user is not found
   * @throws {ValidationError} When userId is invalid
   * 
   * @example
   * const user = await userService.getUser(42);
   * console.log(user.name);
   */
  async getUser(userId) {
    if (!Number.isInteger(userId) || userId <= 0) {
      throw new ValidationError('User ID must be a positive integer');
    }

    const user = await this.repository.findById(userId);
    
    if (!user) {
      throw new NotFoundError(`User ${userId} not found`);
    }

    return user;
  }

  /**
   * Creates a new user
   * @async
   * @param {Object} userData - The user data
   * @param {string} userData.name - User's name
   * @param {string} userData.email - User's email
   * @param {string} userData.role - User's role
   * @returns {Promise<Object>} The created user
   * @throws {ValidationError} When userData is invalid
   */
  async createUser(userData) {
    // Validation
    const { error, value } = userSchema.validate(userData);
    if (error) {
      throw new ValidationError(error.message);
    }

    return this.repository.create(value);
  }
}

module.exports = UserService;
</example>

### Error Handling

<example>
// src/utils/errors.js

/**
 * Base application error
 * @class
 * @extends Error
 */
class AppError extends Error {
  /**
   * @param {string} message - Error message
   * @param {string} code - Error code
   * @param {number} statusCode - HTTP status code
   */
  constructor(message, code, statusCode = 500) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = true;
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * Validation error
 * @class
 * @extends AppError
 */
class ValidationError extends AppError {
  constructor(message) {
    super(message, 'VALIDATION_ERROR', 400);
  }
}

/**
 * Not found error
 * @class
 * @extends AppError
 */
class NotFoundError extends AppError {
  constructor(resource) {
    super(`${resource} not found`, 'NOT_FOUND', 404);
  }
}

/**
 * Wraps async route handlers to catch errors
 * @param {Function} fn - Async function to wrap
 * @returns {Function} Wrapped function
 */
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

module.exports = {
  AppError,
  ValidationError,
  NotFoundError,
  asyncHandler,
};
</example>

### Input Validation (Joi)

<example>
// src/utils/validators.js
const Joi = require('joi');

/**
 * User validation schema
 */
const userSchema = Joi.object({
  name: Joi.string().min(2).max(50).required(),
  email: Joi.string().email().required(),
  role: Joi.string().valid('admin', 'user', 'guest').required(),
  age: Joi.number().integer().min(18).optional(),
});

/**
 * Validates user input
 * @param {Object} data - Data to validate
 * @returns {Object} Validation result
 */
function validateUser(data) {
  return userSchema.validate(data, { abortEarly: false });
}

/**
 * Validation middleware
 * @param {Object} schema - Joi schema
 * @returns {Function} Express middleware
 */
function validate(schema) {
  return (req, res, next) => {
    const { error, value } = schema.validate(req.body, { abortEarly: false });
    
    if (error) {
      const errors = error.details.map((detail) => detail.message);
      return res.status(400).json({
        success: false,
        errors,
      });
    }
    
    req.validatedData = value;
    next();
  };
}

module.exports = {
  validateUser,
  validate,
  userSchema,
};
</example>

## Testing Standards (Jest)

### jest.config.js

<example>
module.exports = {
  testEnvironment: 'node',
  roots: ['<rootDir>/tests'],
  testMatch: ['**/__tests__/**/*.js', '**/?(*.)+(spec|test).js'],
  collectCoverageFrom: [
    'src/**/*.js',
    '!src/**/*.test.js',
    '!src/**/index.js',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  coverageReporters: ['text', 'lcov', 'html'],
  verbose: true,
};
</example>

### Unit Tests

<example>
// tests/unit/userService.test.js
const UserService = require('../../src/services/userService');
const { NotFoundError, ValidationError } = require('../../src/utils/errors');

// Mock the repository
jest.mock('../../src/repositories/userRepository');
const UserRepository = require('../../src/repositories/userRepository');

describe('UserService', () => {
  let userService;
  let mockRepository;

  beforeEach(() => {
    mockRepository = new UserRepository();
    userService = new UserService(mockRepository);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getUser', () => {
    test('should return user when found', async () => {
      // Arrange
      const userId = 42;
      const expectedUser = {
        id: userId,
        name: 'Test User',
        email: 'test@example.com',
        role: 'user',
      };
      mockRepository.findById.mockResolvedValue(expectedUser);

      // Act
      const result = await userService.getUser(userId);

      // Assert
      expect(result).toEqual(expectedUser);
      expect(mockRepository.findById).toHaveBeenCalledWith(userId);
      expect(mockRepository.findById).toHaveBeenCalledTimes(1);
    });

    test('should throw NotFoundError when user not found', async () => {
      // Arrange
      const userId = 999;
      mockRepository.findById.mockResolvedValue(null);

      // Act & Assert
      await expect(userService.getUser(userId)).rejects.toThrow(NotFoundError);
      await expect(userService.getUser(userId)).rejects.toThrow('User 999 not found');
    });

    test.each([
      [0, 'positive integer'],
      [-1, 'positive integer'],
      ['abc', 'positive integer'],
      [null, 'positive integer'],
    ])('should throw ValidationError for invalid ID: %p', async (userId, expectedMessage) => {
      await expect(userService.getUser(userId)).rejects.toThrow(expectedMessage);
    });
  });

  describe('createUser', () => {
    test('should create user with valid data', async () => {
      // Arrange
      const userData = {
        name: 'New User',
        email: 'new@example.com',
        role: 'user',
      };
      const expectedUser = { id: 1, ...userData };
      mockRepository.create.mockResolvedValue(expectedUser);

      // Act
      const result = await userService.createUser(userData);

      // Assert
      expect(result).toEqual(expectedUser);
      expect(mockRepository.create).toHaveBeenCalledWith(userData);
    });
  });
});
</example>

### Integration Tests

<example>
// tests/integration/api.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('User API Integration Tests', () => {
  describe('GET /api/users/:id', () => {
    test('should return user when exists', async () => {
      const response = await request(app)
        .get('/api/users/1')
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        data: {
          id: 1,
          name: expect.any(String),
          email: expect.stringMatching(/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/),
        },
      });
    });

    test('should return 404 when user not found', async () => {
      await request(app)
        .get('/api/users/9999')
        .expect(404)
        .expect((res) => {
          expect(res.body).toHaveProperty('error');
        });
    });
  });

  describe('POST /api/users', () => {
    test('should create new user with valid data', async () => {
      const newUser = {
        name: 'New User',
        email: 'new@example.com',
        role: 'user',
      };

      const response = await request(app)
        .post('/api/users')
        .send(newUser)
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        data: {
          id: expect.any(Number),
          ...newUser,
        },
      });
    });

    test('should return 400 for invalid data', async () => {
      const invalidUser = {
        name: 'A', // Too short
        email: 'invalid-email',
        role: 'invalid-role',
      };

      await request(app)
        .post('/api/users')
        .send(invalidUser)
        .expect(400);
    });
  });
});
</example>

## CI/CD Pipeline (GitLab)

### .gitlab-ci.yml for JavaScript

<example>
# .gitlab-ci.yml
stages:
  - lint
  - test
  - build
  - deploy

variables:
  NODE_VERSION: "18"
  NPM_CONFIG_CACHE: "$CI_PROJECT_DIR/.npm"

cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - .npm/
    - node_modules/

.node_job: &node_template
  image: node:${NODE_VERSION}
  before_script:
    - node --version
    - npm --version
    - npm ci

lint:eslint:
  <<: *node_template
  stage: lint
  script:
    - npm run lint

lint:format:
  <<: *node_template
  stage: lint
  script:
    - npm run format:check

security:audit:
  <<: *node_template
  stage: lint
  script:
    - npm audit --audit-level=moderate
  allow_failure: true

test:unit:
  <<: *node_template
  stage: test
  script:
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 30 days

test:integration:
  <<: *node_template
  stage: test
  script:
    - npm test -- --testPathPattern=integration

build:
  <<: *node_template
  stage: build
  script:
    - npm pack
  artifacts:
    paths:
      - "*.tgz"
    expire_in: 7 days
  only:
    - main
    - tags

deploy:npm:
  <<: *node_template
  stage: deploy
  script:
    - echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > .npmrc
    - npm publish
  only:
    - tags
  when: manual
</example>

## Security Best Practices

### Secure Coding

<example>
// src/utils/security.js
const crypto = require('crypto');
const path = require('path');

/**
 * Hashes a password securely
 * @param {string} password - Plain text password
 * @returns {Promise<string>} Hashed password
 */
async function hashPassword(password) {
  return new Promise((resolve, reject) => {
    const salt = crypto.randomBytes(16).toString('hex');
    
    crypto.scrypt(password, salt, 64, (err, derivedKey) => {
      if (err) reject(err);
      resolve(`${salt}:${derivedKey.toString('hex')}`);
    });
  });
}

/**
 * Verifies a password against hash
 * @param {string} password - Plain text password
 * @param {string} hash - Stored hash
 * @returns {Promise<boolean>} True if password matches
 */
async function verifyPassword(password, hash) {
  return new Promise((resolve, reject) => {
    const [salt, key] = hash.split(':');
    
    crypto.scrypt(password, salt, 64, (err, derivedKey) => {
      if (err) reject(err);
      resolve(key === derivedKey.toString('hex'));
    });
  });
}

/**
 * Generates a secure random token
 * @param {number} length - Token length in bytes
 * @returns {string} Secure token
 */
function generateSecureToken(length = 32) {
  return crypto.randomBytes(length).toString('hex');
}

/**
 * Validates and sanitizes file path
 * @param {string} basePath - Base directory
 * @param {string} userPath - User-provided path
 * @returns {string} Safe path
 * @throws {Error} If path traversal detected
 */
function validatePath(basePath, userPath) {
  const fullPath = path.join(basePath, userPath);
  const normalizedPath = path.normalize(fullPath);
  
  if (!normalizedPath.startsWith(basePath)) {
    throw new Error('Path traversal detected');
  }
  
  return normalizedPath;
}

module.exports = {
  hashPassword,
  verifyPassword,
  generateSecureToken,
  validatePath,
};
</example>

## Logging (Winston)

### Logger Configuration

<example>
// src/config/logger.js
const winston = require('winston');
const path = require('path');

const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

const level = () => {
  const env = process.env.NODE_ENV || 'development';
  return env === 'development' ? 'debug' : 'info';
};

const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

const transports = [
  new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.printf(
        (info) => `${info.timestamp} ${info.level}: ${info.message}`
      )
    ),
  }),
  new winston.transports.File({
    filename: path.join('logs', 'error.log'),
    level: 'error',
  }),
  new winston.transports.File({
    filename: path.join('logs', 'all.log'),
  }),
];

const logger = winston.createLogger({
  level: level(),
  levels,
  format,
  transports,
});

module.exports = logger;
</example>

## Dockerfile

### Production-ready Dockerfile

<example>
# Dockerfile
FROM node:18-alpine AS base

# Install security updates
RUN apk --no-cache upgrade

# Create app directory
WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Copy source
COPY src/ ./src/

# Create non-root user
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
RUN chown -R appuser:appgroup /app

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

# Start application
CMD ["node", "src/index.js"]
</example>

## Release Checklist (JavaScript)

- [ ] All tests pass (`npm test`)
- [ ] Coverage >80% (`npm run test:coverage`)
- [ ] No ESLint errors (`npm run lint`)
- [ ] Code formatted (`npm run format:check`)
- [ ] Security audit clean (`npm audit`)
- [ ] Dependencies up-to-date (`npm outdated`)
- [ ] VERSION file updated
- [ ] package.json version updated
- [ ] CHANGELOG.md updated
- [ ] Git tagged (`git tag v1.0.0`)
- [ ] CI/CD pipeline green

## Summary: JavaScript Enterprise Tools

| Feature | Tool |
|---------|------|
| **Runtime** | Node.js |
| **Testing** | Jest |
| **Coverage** | Jest --coverage |
| **Linting** | ESLint |
| **Formatting** | Prettier |
| **Documentation** | JSDoc |
| **Validation** | Joi |
| **Logging** | Winston |
| **Package Manager** | npm / pnpm / yarn |
